/* This file is generated by code_gen.py */
#include <stdio.h>
#include <stdlib.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <fcntl.h>
#include <sys/mman.h>
#include <string.h>
#include <unistd.h>
#include <malloc.h>
#include <time.h>
#include <getopt.h>
#include <linux/limits.h>
#include "../include/common.h"
#include "../include/hashJoin.h"
#include "../include/schema.h"
#include "../include/cpuCudaLib.h"
#include "../include/gpuCudaLib.h"
extern struct tableNode* tableScan(struct scanNode *,struct statistic *);
extern struct tableNode* hashJoin(struct joinNode *, struct statistic *);
extern struct tableNode* groupBy(struct groupByNode *,struct statistic *);
extern struct tableNode* orderBy(struct orderByNode *, struct statistic *);
extern void materializeCol(struct materializeNode * mn, struct statistic *);
#define CHECK_POINTER(p) do {\
	if(p == NULL){   \
		perror("Failed to allocate host memory");    \
		exit(-1);      \
	}} while(0)

int call(int argc, char ** argv){
/* For initializing CUDA device */
	int * cudaTmp;
	cudaMalloc((void**)&cudaTmp,sizeof(int));
	cudaFree(cudaTmp);

	struct timeval t;
	gettimeofday(&t, NULL);
	printf("[gvm] %lf BEGIN\n", t.tv_sec + t.tv_usec / 1000000.0);
	int table;
	int long_index;
	char path[PATH_MAX];
	int setPath = 0;
	struct option long_options[] = {
		{"datadir",required_argument,0,'0'}
	};

	while((table=getopt_long(argc,argv,"",long_options,&long_index))!=-1){
		switch(table){
			case '0':
				setPath = 1;
				strcpy(path,optarg);
				break;
		}
	}

	if(setPath == 1)
		chdir(path);

	struct timespec start,end;
	struct timespec diskStart, diskEnd;
	double diskTotal = 0;
	clock_gettime(CLOCK_REALTIME,&start);
	struct statistic pp;
	pp.total = pp.kernel = pp.pcie = 0;
	struct tableNode *result = (struct tableNode*) malloc(sizeof(struct tableNode));
	CHECK_POINTER(result);
	initTable(result);
	struct tableNode *customerTable;
	struct tableNode *supplierTable;
	struct tableNode *partTable;
	struct tableNode *ddateTable;
	int outFd;
	long outSize;
	char *outTable;
	long offset, tupleOffset;
	int blockTotal;
	struct columnHeader header;

	outFd = open("CUSTOMER0",O_RDONLY);
	read(outFd,&header, sizeof(struct columnHeader));
	blockTotal = header.blockTotal;
	close(outFd);
	offset=0;
	tupleOffset=0;
	struct tableNode *customerRes = (struct tableNode *)malloc(sizeof(struct tableNode));
	CHECK_POINTER(customerRes);
	initTable(customerRes);
	for(int i=0;i<blockTotal;i++){
		customerTable = (struct tableNode *) malloc(sizeof(struct tableNode));
		CHECK_POINTER(customerTable);
		customerTable->totalAttr = 2;
		customerTable->attrType = (int *) malloc(sizeof(int)*2);
		CHECK_POINTER(customerTable->attrType);
		customerTable->attrSize = (int *) malloc(sizeof(int)*2);
		CHECK_POINTER(customerTable->attrSize);
		customerTable->attrIndex = (int *) malloc(sizeof(int)*2);
		CHECK_POINTER(customerTable->attrIndex);
		customerTable->attrTotalSize = (int *) malloc(sizeof(int)*2);
		CHECK_POINTER(customerTable->attrTotalSize);
		customerTable->dataPos = (int *) malloc(sizeof(int)*2);
		CHECK_POINTER(customerTable->dataPos);
		customerTable->dataFormat = (int *) malloc(sizeof(int)*2);
		CHECK_POINTER(customerTable->dataFormat);
		customerTable->content = (char **) malloc(sizeof(char *)*2);
		CHECK_POINTER(customerTable->content);
		customerTable->attrSize[0] = sizeof(int);
		customerTable->attrIndex[0] = 0;
		customerTable->attrType[0] = INT;
		customerTable->dataPos[0] = MMAP;
		outFd = open("CUSTOMER0",O_RDONLY);
		offset = i * sizeof(struct columnHeader) + tupleOffset *sizeof(int);
		lseek(outFd,offset,SEEK_SET);
		read(outFd,&header, sizeof(struct columnHeader));
		offset += sizeof(struct columnHeader);
		customerTable->dataFormat[0] = header.format;
		outSize = header.tupleNum * sizeof(int);
		customerTable->attrTotalSize[0] = outSize;
		clock_gettime(CLOCK_REALTIME,&diskStart);
		outTable =(char *) mmap(0,outSize,PROT_READ,MAP_SHARED,outFd,offset);

		customerTable->content[0] = (char *)mmap(0,outSize,PROT_READ,MAP_SHARED,outFd,offset);
		munmap(outTable,outSize);
		clock_gettime(CLOCK_REALTIME,&diskEnd);
		diskTotal += (diskEnd.tv_sec -  diskStart.tv_sec)* BILLION + diskEnd.tv_nsec - diskStart.tv_nsec;
		close(outFd);
		customerTable->attrSize[1] = 12;
		customerTable->attrIndex[1] = 5;
		customerTable->attrType[1] = STRING;
		customerTable->dataPos[1] = MMAP;
		outFd = open("CUSTOMER5",O_RDONLY);
		offset = i * sizeof(struct columnHeader) + tupleOffset *12;
		lseek(outFd,offset,SEEK_SET);
		read(outFd,&header, sizeof(struct columnHeader));
		offset += sizeof(struct columnHeader);
		customerTable->dataFormat[1] = header.format;
		outSize = header.tupleNum * 12;
		customerTable->attrTotalSize[1] = outSize;
		clock_gettime(CLOCK_REALTIME,&diskStart);
		outTable =(char *) mmap(0,outSize,PROT_READ,MAP_SHARED,outFd,offset);

		customerTable->content[1] = (char *)mmap(0,outSize,PROT_READ,MAP_SHARED,outFd,offset);
		munmap(outTable,outSize);
		clock_gettime(CLOCK_REALTIME,&diskEnd);
		diskTotal += (diskEnd.tv_sec -  diskStart.tv_sec)* BILLION + diskEnd.tv_nsec - diskStart.tv_nsec;
		close(outFd);
		customerTable->tupleSize = 0 + sizeof(int) + sizeof(int) + 12;

		customerTable->tupleNum = header.tupleNum;
		struct scanNode customerRel;
		customerRel.tn = customerTable;
		customerRel.hasWhere = 1;
		customerRel.whereAttrNum = 1;
		customerRel.whereIndex = (int *)malloc(sizeof(int)*1);
		CHECK_POINTER(customerRel.whereIndex);
		customerRel.outputNum = 1;
		customerRel.outputIndex = (int *)malloc(sizeof(int) * 1);
		CHECK_POINTER(customerRel.outputIndex);
		customerRel.outputIndex[0] = 0;
		customerRel.whereIndex[0] = 1;
		customerRel.keepInGpu = 1;
		customerRel.filter = (struct whereCondition *)malloc(sizeof(struct whereCondition));
		CHECK_POINTER(customerRel.filter);
		(customerRel.filter)->nested = 0;
		(customerRel.filter)->expNum = 1;
		(customerRel.filter)->exp = (struct whereExp*) malloc(sizeof(struct whereExp) *1);
		CHECK_POINTER((customerRel.filter)->exp);
		(customerRel.filter)->andOr = EXP;
		(customerRel.filter)->exp[0].index = 0;
		(customerRel.filter)->exp[0].relation = EQ;
		strcpy((customerRel.filter)->exp[0].content,"AMERICA");

		struct tableNode *tmp = tableScan(&customerRel, &pp);
		if(blockTotal !=1){
			mergeIntoTable(customerRes,tmp,&pp);
		}else{
			free(customerRes);
			customerRes = tmp;
		}
		clock_gettime(CLOCK_REALTIME,&diskStart);
		freeScan(&customerRel);

		clock_gettime(CLOCK_REALTIME,&diskEnd);
		diskTotal += (diskEnd.tv_sec -  diskStart.tv_sec)* BILLION + diskEnd.tv_nsec - diskStart.tv_nsec;
		tupleOffset += header.tupleNum;

	}

	outFd = open("SUPPLIER4",O_RDONLY);
	read(outFd,&header, sizeof(struct columnHeader));
	blockTotal = header.blockTotal;
	close(outFd);
	offset=0;
	tupleOffset=0;
	struct tableNode *supplierRes = (struct tableNode *)malloc(sizeof(struct tableNode));
	CHECK_POINTER(supplierRes);
	initTable(supplierRes);
	for(int i=0;i<blockTotal;i++){
		supplierTable = (struct tableNode *) malloc(sizeof(struct tableNode));
		CHECK_POINTER(supplierTable);
		supplierTable->totalAttr = 3;
		supplierTable->attrType = (int *) malloc(sizeof(int)*3);
		CHECK_POINTER(supplierTable->attrType);
		supplierTable->attrSize = (int *) malloc(sizeof(int)*3);
		CHECK_POINTER(supplierTable->attrSize);
		supplierTable->attrIndex = (int *) malloc(sizeof(int)*3);
		CHECK_POINTER(supplierTable->attrIndex);
		supplierTable->attrTotalSize = (int *) malloc(sizeof(int)*3);
		CHECK_POINTER(supplierTable->attrTotalSize);
		supplierTable->dataPos = (int *) malloc(sizeof(int)*3);
		CHECK_POINTER(supplierTable->dataPos);
		supplierTable->dataFormat = (int *) malloc(sizeof(int)*3);
		CHECK_POINTER(supplierTable->dataFormat);
		supplierTable->content = (char **) malloc(sizeof(char *)*3);
		CHECK_POINTER(supplierTable->content);
		supplierTable->attrSize[0] = 15;
		supplierTable->attrIndex[0] = 4;
		supplierTable->attrType[0] = STRING;
		supplierTable->dataPos[0] = MMAP;
		outFd = open("SUPPLIER4",O_RDONLY);
		offset = i * sizeof(struct columnHeader) + tupleOffset *15;
		lseek(outFd,offset,SEEK_SET);
		read(outFd,&header, sizeof(struct columnHeader));
		offset += sizeof(struct columnHeader);
		supplierTable->dataFormat[0] = header.format;
		outSize = header.tupleNum * 15;
		supplierTable->attrTotalSize[0] = outSize;
		clock_gettime(CLOCK_REALTIME,&diskStart);
		outTable =(char *) mmap(0,outSize,PROT_READ,MAP_SHARED,outFd,offset);

		supplierTable->content[0] = (char *)mmap(0,outSize,PROT_READ,MAP_SHARED,outFd,offset);
		munmap(outTable,outSize);
		clock_gettime(CLOCK_REALTIME,&diskEnd);
		diskTotal += (diskEnd.tv_sec -  diskStart.tv_sec)* BILLION + diskEnd.tv_nsec - diskStart.tv_nsec;
		close(outFd);
		supplierTable->attrSize[1] = sizeof(int);
		supplierTable->attrIndex[1] = 0;
		supplierTable->attrType[1] = INT;
		supplierTable->dataPos[1] = MMAP;
		outFd = open("SUPPLIER0",O_RDONLY);
		offset = i * sizeof(struct columnHeader) + tupleOffset *sizeof(int);
		lseek(outFd,offset,SEEK_SET);
		read(outFd,&header, sizeof(struct columnHeader));
		offset += sizeof(struct columnHeader);
		supplierTable->dataFormat[1] = header.format;
		outSize = header.tupleNum * sizeof(int);
		supplierTable->attrTotalSize[1] = outSize;
		clock_gettime(CLOCK_REALTIME,&diskStart);
		outTable =(char *) mmap(0,outSize,PROT_READ,MAP_SHARED,outFd,offset);

		supplierTable->content[1] = (char *)mmap(0,outSize,PROT_READ,MAP_SHARED,outFd,offset);
		munmap(outTable,outSize);
		clock_gettime(CLOCK_REALTIME,&diskEnd);
		diskTotal += (diskEnd.tv_sec -  diskStart.tv_sec)* BILLION + diskEnd.tv_nsec - diskStart.tv_nsec;
		close(outFd);
		supplierTable->attrSize[2] = 12;
		supplierTable->attrIndex[2] = 5;
		supplierTable->attrType[2] = STRING;
		supplierTable->dataPos[2] = MMAP;
		outFd = open("SUPPLIER5",O_RDONLY);
		offset = i * sizeof(struct columnHeader) + tupleOffset *12;
		lseek(outFd,offset,SEEK_SET);
		read(outFd,&header, sizeof(struct columnHeader));
		offset += sizeof(struct columnHeader);
		supplierTable->dataFormat[2] = header.format;
		outSize = header.tupleNum * 12;
		supplierTable->attrTotalSize[2] = outSize;
		clock_gettime(CLOCK_REALTIME,&diskStart);
		outTable =(char *) mmap(0,outSize,PROT_READ,MAP_SHARED,outFd,offset);

		supplierTable->content[2] = (char *)mmap(0,outSize,PROT_READ,MAP_SHARED,outFd,offset);
		munmap(outTable,outSize);
		clock_gettime(CLOCK_REALTIME,&diskEnd);
		diskTotal += (diskEnd.tv_sec -  diskStart.tv_sec)* BILLION + diskEnd.tv_nsec - diskStart.tv_nsec;
		close(outFd);
		supplierTable->tupleSize = 0 + 15 + 15 + sizeof(int) + 12;

		supplierTable->tupleNum = header.tupleNum;
		struct scanNode supplierRel;
		supplierRel.tn = supplierTable;
		supplierRel.hasWhere = 1;
		supplierRel.whereAttrNum = 1;
		supplierRel.whereIndex = (int *)malloc(sizeof(int)*1);
		CHECK_POINTER(supplierRel.whereIndex);
		supplierRel.outputNum = 2;
		supplierRel.outputIndex = (int *)malloc(sizeof(int) * 2);
		CHECK_POINTER(supplierRel.outputIndex);
		supplierRel.outputIndex[0] = 0;
		supplierRel.outputIndex[1] = 1;
		supplierRel.whereIndex[0] = 2;
		supplierRel.keepInGpu = 1;
		supplierRel.filter = (struct whereCondition *)malloc(sizeof(struct whereCondition));
		CHECK_POINTER(supplierRel.filter);
		(supplierRel.filter)->nested = 0;
		(supplierRel.filter)->expNum = 1;
		(supplierRel.filter)->exp = (struct whereExp*) malloc(sizeof(struct whereExp) *1);
		CHECK_POINTER((supplierRel.filter)->exp);
		(supplierRel.filter)->andOr = EXP;
		(supplierRel.filter)->exp[0].index = 0;
		(supplierRel.filter)->exp[0].relation = EQ;
		strcpy((supplierRel.filter)->exp[0].content,"AMERICA");

		struct tableNode *tmp = tableScan(&supplierRel, &pp);
		if(blockTotal !=1){
			mergeIntoTable(supplierRes,tmp,&pp);
		}else{
			free(supplierRes);
			supplierRes = tmp;
		}
		clock_gettime(CLOCK_REALTIME,&diskStart);
		freeScan(&supplierRel);

		clock_gettime(CLOCK_REALTIME,&diskEnd);
		diskTotal += (diskEnd.tv_sec -  diskStart.tv_sec)* BILLION + diskEnd.tv_nsec - diskStart.tv_nsec;
		tupleOffset += header.tupleNum;

	}

	outFd = open("PART3",O_RDONLY);
	read(outFd,&header, sizeof(struct columnHeader));
	blockTotal = header.blockTotal;
	close(outFd);
	offset=0;
	tupleOffset=0;
	struct tableNode *partRes = (struct tableNode *)malloc(sizeof(struct tableNode));
	CHECK_POINTER(partRes);
	initTable(partRes);
	for(int i=0;i<blockTotal;i++){
		partTable = (struct tableNode *) malloc(sizeof(struct tableNode));
		CHECK_POINTER(partTable);
		partTable->totalAttr = 3;
		partTable->attrType = (int *) malloc(sizeof(int)*3);
		CHECK_POINTER(partTable->attrType);
		partTable->attrSize = (int *) malloc(sizeof(int)*3);
		CHECK_POINTER(partTable->attrSize);
		partTable->attrIndex = (int *) malloc(sizeof(int)*3);
		CHECK_POINTER(partTable->attrIndex);
		partTable->attrTotalSize = (int *) malloc(sizeof(int)*3);
		CHECK_POINTER(partTable->attrTotalSize);
		partTable->dataPos = (int *) malloc(sizeof(int)*3);
		CHECK_POINTER(partTable->dataPos);
		partTable->dataFormat = (int *) malloc(sizeof(int)*3);
		CHECK_POINTER(partTable->dataFormat);
		partTable->content = (char **) malloc(sizeof(char *)*3);
		CHECK_POINTER(partTable->content);
		partTable->attrSize[0] = 7;
		partTable->attrIndex[0] = 3;
		partTable->attrType[0] = STRING;
		partTable->dataPos[0] = MMAP;
		outFd = open("PART3",O_RDONLY);
		offset = i * sizeof(struct columnHeader) + tupleOffset *7;
		lseek(outFd,offset,SEEK_SET);
		read(outFd,&header, sizeof(struct columnHeader));
		offset += sizeof(struct columnHeader);
		partTable->dataFormat[0] = header.format;
		outSize = header.tupleNum * 7;
		partTable->attrTotalSize[0] = outSize;
		clock_gettime(CLOCK_REALTIME,&diskStart);
		outTable =(char *) mmap(0,outSize,PROT_READ,MAP_SHARED,outFd,offset);

		partTable->content[0] = (char *)mmap(0,outSize,PROT_READ,MAP_SHARED,outFd,offset);
		munmap(outTable,outSize);
		clock_gettime(CLOCK_REALTIME,&diskEnd);
		diskTotal += (diskEnd.tv_sec -  diskStart.tv_sec)* BILLION + diskEnd.tv_nsec - diskStart.tv_nsec;
		close(outFd);
		partTable->attrSize[1] = sizeof(int);
		partTable->attrIndex[1] = 0;
		partTable->attrType[1] = INT;
		partTable->dataPos[1] = MMAP;
		outFd = open("PART0",O_RDONLY);
		offset = i * sizeof(struct columnHeader) + tupleOffset *sizeof(int);
		lseek(outFd,offset,SEEK_SET);
		read(outFd,&header, sizeof(struct columnHeader));
		offset += sizeof(struct columnHeader);
		partTable->dataFormat[1] = header.format;
		outSize = header.tupleNum * sizeof(int);
		partTable->attrTotalSize[1] = outSize;
		clock_gettime(CLOCK_REALTIME,&diskStart);
		outTable =(char *) mmap(0,outSize,PROT_READ,MAP_SHARED,outFd,offset);

		partTable->content[1] = (char *)mmap(0,outSize,PROT_READ,MAP_SHARED,outFd,offset);
		munmap(outTable,outSize);
		clock_gettime(CLOCK_REALTIME,&diskEnd);
		diskTotal += (diskEnd.tv_sec -  diskStart.tv_sec)* BILLION + diskEnd.tv_nsec - diskStart.tv_nsec;
		close(outFd);
		partTable->attrSize[2] = 6;
		partTable->attrIndex[2] = 2;
		partTable->attrType[2] = STRING;
		partTable->dataPos[2] = MMAP;
		outFd = open("PART2",O_RDONLY);
		offset = i * sizeof(struct columnHeader) + tupleOffset *6;
		lseek(outFd,offset,SEEK_SET);
		read(outFd,&header, sizeof(struct columnHeader));
		offset += sizeof(struct columnHeader);
		partTable->dataFormat[2] = header.format;
		outSize = header.tupleNum * 6;
		partTable->attrTotalSize[2] = outSize;
		clock_gettime(CLOCK_REALTIME,&diskStart);
		outTable =(char *) mmap(0,outSize,PROT_READ,MAP_SHARED,outFd,offset);

		partTable->content[2] = (char *)mmap(0,outSize,PROT_READ,MAP_SHARED,outFd,offset);
		munmap(outTable,outSize);
		clock_gettime(CLOCK_REALTIME,&diskEnd);
		diskTotal += (diskEnd.tv_sec -  diskStart.tv_sec)* BILLION + diskEnd.tv_nsec - diskStart.tv_nsec;
		close(outFd);
		partTable->tupleSize = 0 + 7 + 7 + sizeof(int) + 6;

		partTable->tupleNum = header.tupleNum;
		struct scanNode partRel;
		partRel.tn = partTable;
		partRel.hasWhere = 1;
		partRel.whereAttrNum = 1;
		partRel.whereIndex = (int *)malloc(sizeof(int)*2);
		CHECK_POINTER(partRel.whereIndex);
		partRel.outputNum = 2;
		partRel.outputIndex = (int *)malloc(sizeof(int) * 2);
		CHECK_POINTER(partRel.outputIndex);
		partRel.outputIndex[0] = 0;
		partRel.outputIndex[1] = 1;
		partRel.whereIndex[0] = 2;
		partRel.keepInGpu = 1;
		partRel.filter = (struct whereCondition *)malloc(sizeof(struct whereCondition));
		CHECK_POINTER(partRel.filter);
		(partRel.filter)->nested = 0;
		(partRel.filter)->expNum = 2;
		(partRel.filter)->exp = (struct whereExp*) malloc(sizeof(struct whereExp) *2);
		CHECK_POINTER((partRel.filter)->exp);
		(partRel.filter)->andOr = OR;
		(partRel.filter)->exp[0].index = 0;
		(partRel.filter)->exp[0].relation = EQ;
		strcpy((partRel.filter)->exp[0].content,"MFGR#1");

		(partRel.filter)->exp[1].index = 0;
		(partRel.filter)->exp[1].relation = EQ;
		strcpy((partRel.filter)->exp[1].content,"MFGR#2");

		struct tableNode *tmp = tableScan(&partRel, &pp);
		if(blockTotal !=1){
			mergeIntoTable(partRes,tmp,&pp);
		}else{
			free(partRes);
			partRes = tmp;
		}
		clock_gettime(CLOCK_REALTIME,&diskStart);
		freeScan(&partRel);

		clock_gettime(CLOCK_REALTIME,&diskEnd);
		diskTotal += (diskEnd.tv_sec -  diskStart.tv_sec)* BILLION + diskEnd.tv_nsec - diskStart.tv_nsec;
		tupleOffset += header.tupleNum;

	}

	outFd = open("DDATE4",O_RDONLY);
	read(outFd,&header, sizeof(struct columnHeader));
	blockTotal = header.blockTotal;
	close(outFd);
	offset=0;
	tupleOffset=0;
	struct tableNode *ddateRes = (struct tableNode *)malloc(sizeof(struct tableNode));
	CHECK_POINTER(ddateRes);
	initTable(ddateRes);
	for(int i=0;i<blockTotal;i++){
		ddateTable = (struct tableNode *) malloc(sizeof(struct tableNode));
		CHECK_POINTER(ddateTable);
		ddateTable->totalAttr = 2;
		ddateTable->attrType = (int *) malloc(sizeof(int)*2);
		CHECK_POINTER(ddateTable->attrType);
		ddateTable->attrSize = (int *) malloc(sizeof(int)*2);
		CHECK_POINTER(ddateTable->attrSize);
		ddateTable->attrIndex = (int *) malloc(sizeof(int)*2);
		CHECK_POINTER(ddateTable->attrIndex);
		ddateTable->attrTotalSize = (int *) malloc(sizeof(int)*2);
		CHECK_POINTER(ddateTable->attrTotalSize);
		ddateTable->dataPos = (int *) malloc(sizeof(int)*2);
		CHECK_POINTER(ddateTable->dataPos);
		ddateTable->dataFormat = (int *) malloc(sizeof(int)*2);
		CHECK_POINTER(ddateTable->dataFormat);
		ddateTable->content = (char **) malloc(sizeof(char *)*2);
		CHECK_POINTER(ddateTable->content);
		ddateTable->attrSize[0] = sizeof(int);
		ddateTable->attrIndex[0] = 4;
		ddateTable->attrType[0] = INT;
		ddateTable->dataPos[0] = MMAP;
		outFd = open("DDATE4",O_RDONLY);
		offset = i * sizeof(struct columnHeader) + tupleOffset *sizeof(int);
		lseek(outFd,offset,SEEK_SET);
		read(outFd,&header, sizeof(struct columnHeader));
		offset += sizeof(struct columnHeader);
		ddateTable->dataFormat[0] = header.format;
		outSize = header.tupleNum * sizeof(int);
		ddateTable->attrTotalSize[0] = outSize;
		clock_gettime(CLOCK_REALTIME,&diskStart);
		outTable =(char *) mmap(0,outSize,PROT_READ,MAP_SHARED,outFd,offset);

		ddateTable->content[0] = (char *)mmap(0,outSize,PROT_READ,MAP_SHARED,outFd,offset);
		munmap(outTable,outSize);
		clock_gettime(CLOCK_REALTIME,&diskEnd);
		diskTotal += (diskEnd.tv_sec -  diskStart.tv_sec)* BILLION + diskEnd.tv_nsec - diskStart.tv_nsec;
		close(outFd);
		ddateTable->attrSize[1] = sizeof(int);
		ddateTable->attrIndex[1] = 0;
		ddateTable->attrType[1] = INT;
		ddateTable->dataPos[1] = MMAP;
		outFd = open("DDATE0",O_RDONLY);
		offset = i * sizeof(struct columnHeader) + tupleOffset *sizeof(int);
		lseek(outFd,offset,SEEK_SET);
		read(outFd,&header, sizeof(struct columnHeader));
		offset += sizeof(struct columnHeader);
		ddateTable->dataFormat[1] = header.format;
		outSize = header.tupleNum * sizeof(int);
		ddateTable->attrTotalSize[1] = outSize;
		clock_gettime(CLOCK_REALTIME,&diskStart);
		outTable =(char *) mmap(0,outSize,PROT_READ,MAP_SHARED,outFd,offset);

		ddateTable->content[1] = (char *)mmap(0,outSize,PROT_READ,MAP_SHARED,outFd,offset);
		munmap(outTable,outSize);
		clock_gettime(CLOCK_REALTIME,&diskEnd);
		diskTotal += (diskEnd.tv_sec -  diskStart.tv_sec)* BILLION + diskEnd.tv_nsec - diskStart.tv_nsec;
		close(outFd);
		ddateTable->tupleSize = 0 + sizeof(int) + sizeof(int) + sizeof(int);

		ddateTable->tupleNum = header.tupleNum;
		struct scanNode ddateRel;
		ddateRel.tn = ddateTable;
		ddateRel.hasWhere = 1;
		ddateRel.whereAttrNum = 1;
		ddateRel.whereIndex = (int *)malloc(sizeof(int)*2);
		CHECK_POINTER(ddateRel.whereIndex);
		ddateRel.outputNum = 2;
		ddateRel.outputIndex = (int *)malloc(sizeof(int) * 2);
		CHECK_POINTER(ddateRel.outputIndex);
		ddateRel.outputIndex[0] = 0;
		ddateRel.outputIndex[1] = 1;
		ddateRel.whereIndex[0] = 0;
		ddateRel.keepInGpu = 1;
		ddateRel.filter = (struct whereCondition *)malloc(sizeof(struct whereCondition));
		CHECK_POINTER(ddateRel.filter);
		(ddateRel.filter)->nested = 0;
		(ddateRel.filter)->expNum = 2;
		(ddateRel.filter)->exp = (struct whereExp*) malloc(sizeof(struct whereExp) *2);
		CHECK_POINTER((ddateRel.filter)->exp);
		(ddateRel.filter)->andOr = OR;
		(ddateRel.filter)->exp[0].index = 0;
		(ddateRel.filter)->exp[0].relation = EQ;
		{
			int tmp = 1997;
			memcpy((ddateRel.filter)->exp[0].content, &tmp,sizeof(int));
		}
		(ddateRel.filter)->exp[1].index = 0;
		(ddateRel.filter)->exp[1].relation = EQ;
		{
			int tmp = 1998;
			memcpy((ddateRel.filter)->exp[1].content, &tmp,sizeof(int));
		}
		struct tableNode *tmp = tableScan(&ddateRel, &pp);
		if(blockTotal !=1){
			mergeIntoTable(ddateRes,tmp,&pp);
		}else{
			free(ddateRes);
			ddateRes = tmp;
		}
		clock_gettime(CLOCK_REALTIME,&diskStart);
		freeScan(&ddateRel);

		clock_gettime(CLOCK_REALTIME,&diskEnd);
		diskTotal += (diskEnd.tv_sec -  diskStart.tv_sec)* BILLION + diskEnd.tv_nsec - diskStart.tv_nsec;
		tupleOffset += header.tupleNum;

	}

	outFd = open("LINEORDER12",O_RDONLY);
	read(outFd, &header, sizeof(struct columnHeader));
	blockTotal = header.blockTotal;
	close(outFd);
	offset = 0;
	long blockSize[6];
	for(int i=0;i<6;i++)
		blockSize[i] = 0;
	for(int i=0;i<blockTotal;i++){

		struct tableNode *lineorderTable = (struct tableNode*)malloc(sizeof(struct tableNode));
		CHECK_POINTER(lineorderTable);
		lineorderTable->totalAttr = 6;
		lineorderTable->attrType = (int *) malloc(sizeof(int)*6);
		CHECK_POINTER(lineorderTable->attrType);
		lineorderTable->attrSize = (int *) malloc(sizeof(int)*6);
		CHECK_POINTER(lineorderTable->attrSize);
		lineorderTable->attrIndex = (int *) malloc(sizeof(int)*6);
		CHECK_POINTER(lineorderTable->attrIndex);
		lineorderTable->attrTotalSize = (int *) malloc(sizeof(int)*6);
		CHECK_POINTER(lineorderTable->attrTotalSize);
		lineorderTable->dataPos = (int *) malloc(sizeof(int)*6);
		CHECK_POINTER(lineorderTable->dataPos);
		lineorderTable->dataFormat = (int *) malloc(sizeof(int)*6);
		CHECK_POINTER(lineorderTable->dataFormat);
		lineorderTable->content = (char **) malloc(sizeof(char *)*6);
		CHECK_POINTER(lineorderTable->content);
		lineorderTable->attrType[0] = INT;
		lineorderTable->attrSize[0] = sizeof(int);
		lineorderTable->attrIndex[0] = 12;
		lineorderTable->dataPos[0] = MMAP;
		outFd = open("LINEORDER12", O_RDONLY);
		offset = i*sizeof(struct columnHeader) + blockSize[0];
		lseek(outFd,offset,SEEK_SET);
		read(outFd, &header, sizeof(struct columnHeader));
		blockSize[0] += header.blockSize;
		offset += sizeof(struct columnHeader);
		lineorderTable->dataFormat[0] = header.format;
		outSize = header.blockSize;
		clock_gettime(CLOCK_REALTIME,&diskStart);
		outTable = (char *)mmap(0,outSize,PROT_READ,MAP_SHARED,outFd,offset);
		lineorderTable->content[0] = (char *)mmap(0,outSize,PROT_READ,MAP_SHARED,outFd,offset);
		munmap(outTable,outSize);
		clock_gettime(CLOCK_REALTIME,&diskEnd);
		diskTotal += (diskEnd.tv_sec -  diskStart.tv_sec)* BILLION + diskEnd.tv_nsec - diskStart.tv_nsec;
		close(outFd);
		lineorderTable->attrTotalSize[0] = outSize;
		lineorderTable->attrType[1] = INT;
		lineorderTable->attrSize[1] = sizeof(int);
		lineorderTable->attrIndex[1] = 13;
		lineorderTable->dataPos[1] = MMAP;
		outFd = open("LINEORDER13", O_RDONLY);
		offset = i*sizeof(struct columnHeader) + blockSize[1];
		lseek(outFd,offset,SEEK_SET);
		read(outFd, &header, sizeof(struct columnHeader));
		blockSize[1] += header.blockSize;
		offset += sizeof(struct columnHeader);
		lineorderTable->dataFormat[1] = header.format;
		outSize = header.blockSize;
		clock_gettime(CLOCK_REALTIME,&diskStart);
		outTable = (char *)mmap(0,outSize,PROT_READ,MAP_SHARED,outFd,offset);
		lineorderTable->content[1] = (char *)mmap(0,outSize,PROT_READ,MAP_SHARED,outFd,offset);
		munmap(outTable,outSize);
		clock_gettime(CLOCK_REALTIME,&diskEnd);
		diskTotal += (diskEnd.tv_sec -  diskStart.tv_sec)* BILLION + diskEnd.tv_nsec - diskStart.tv_nsec;
		close(outFd);
		lineorderTable->attrTotalSize[1] = outSize;
		lineorderTable->attrType[2] = INT;
		lineorderTable->attrSize[2] = sizeof(int);
		lineorderTable->attrIndex[2] = 5;
		lineorderTable->dataPos[2] = MMAP;
		outFd = open("LINEORDER5", O_RDONLY);
		offset = i*sizeof(struct columnHeader) + blockSize[2];
		lseek(outFd,offset,SEEK_SET);
		read(outFd, &header, sizeof(struct columnHeader));
		blockSize[2] += header.blockSize;
		offset += sizeof(struct columnHeader);
		lineorderTable->dataFormat[2] = header.format;
		outSize = header.blockSize;
		clock_gettime(CLOCK_REALTIME,&diskStart);
		outTable = (char *)mmap(0,outSize,PROT_READ,MAP_SHARED,outFd,offset);
		lineorderTable->content[2] = (char *)mmap(0,outSize,PROT_READ,MAP_SHARED,outFd,offset);
		munmap(outTable,outSize);
		clock_gettime(CLOCK_REALTIME,&diskEnd);
		diskTotal += (diskEnd.tv_sec -  diskStart.tv_sec)* BILLION + diskEnd.tv_nsec - diskStart.tv_nsec;
		close(outFd);
		lineorderTable->attrTotalSize[2] = outSize;
		lineorderTable->attrType[3] = INT;
		lineorderTable->attrSize[3] = sizeof(int);
		lineorderTable->attrIndex[3] = 3;
		lineorderTable->dataPos[3] = MMAP;
		outFd = open("LINEORDER3", O_RDONLY);
		offset = i*sizeof(struct columnHeader) + blockSize[3];
		lseek(outFd,offset,SEEK_SET);
		read(outFd, &header, sizeof(struct columnHeader));
		blockSize[3] += header.blockSize;
		offset += sizeof(struct columnHeader);
		lineorderTable->dataFormat[3] = header.format;
		outSize = header.blockSize;
		clock_gettime(CLOCK_REALTIME,&diskStart);
		outTable = (char *)mmap(0,outSize,PROT_READ,MAP_SHARED,outFd,offset);
		lineorderTable->content[3] = (char *)mmap(0,outSize,PROT_READ,MAP_SHARED,outFd,offset);
		munmap(outTable,outSize);
		clock_gettime(CLOCK_REALTIME,&diskEnd);
		diskTotal += (diskEnd.tv_sec -  diskStart.tv_sec)* BILLION + diskEnd.tv_nsec - diskStart.tv_nsec;
		close(outFd);
		lineorderTable->attrTotalSize[3] = outSize;
		lineorderTable->attrType[4] = INT;
		lineorderTable->attrSize[4] = sizeof(int);
		lineorderTable->attrIndex[4] = 4;
		lineorderTable->dataPos[4] = MMAP;
		outFd = open("LINEORDER4", O_RDONLY);
		offset = i*sizeof(struct columnHeader) + blockSize[4];
		lseek(outFd,offset,SEEK_SET);
		read(outFd, &header, sizeof(struct columnHeader));
		blockSize[4] += header.blockSize;
		offset += sizeof(struct columnHeader);
		lineorderTable->dataFormat[4] = header.format;
		outSize = header.blockSize;
		clock_gettime(CLOCK_REALTIME,&diskStart);
		outTable = (char *)mmap(0,outSize,PROT_READ,MAP_SHARED,outFd,offset);
		lineorderTable->content[4] = (char *)mmap(0,outSize,PROT_READ,MAP_SHARED,outFd,offset);
		munmap(outTable,outSize);
		clock_gettime(CLOCK_REALTIME,&diskEnd);
		diskTotal += (diskEnd.tv_sec -  diskStart.tv_sec)* BILLION + diskEnd.tv_nsec - diskStart.tv_nsec;
		close(outFd);
		lineorderTable->attrTotalSize[4] = outSize;
		lineorderTable->attrType[5] = INT;
		lineorderTable->attrSize[5] = sizeof(int);
		lineorderTable->attrIndex[5] = 2;
		lineorderTable->dataPos[5] = MMAP;
		outFd = open("LINEORDER2", O_RDONLY);
		offset = i*sizeof(struct columnHeader) + blockSize[5];
		lseek(outFd,offset,SEEK_SET);
		read(outFd, &header, sizeof(struct columnHeader));
		blockSize[5] += header.blockSize;
		offset += sizeof(struct columnHeader);
		lineorderTable->dataFormat[5] = header.format;
		outSize = header.blockSize;
		clock_gettime(CLOCK_REALTIME,&diskStart);
		outTable = (char *)mmap(0,outSize,PROT_READ,MAP_SHARED,outFd,offset);
		lineorderTable->content[5] = (char *)mmap(0,outSize,PROT_READ,MAP_SHARED,outFd,offset);
		munmap(outTable,outSize);
		clock_gettime(CLOCK_REALTIME,&diskEnd);
		diskTotal += (diskEnd.tv_sec -  diskStart.tv_sec)* BILLION + diskEnd.tv_nsec - diskStart.tv_nsec;
		close(outFd);
		lineorderTable->attrTotalSize[5] = outSize;
		lineorderTable->tupleSize = 0 + sizeof(int) + sizeof(int) + sizeof(int) + sizeof(int) + sizeof(int) + sizeof(int);

		lineorderTable->tupleNum = header.tupleNum;
		struct tableNode * lineorderRes = lineorderTable;
		struct joinNode jNode0;
		jNode0.leftTable = lineorderRes;
		jNode0.rightTable = customerRes;
		jNode0.totalAttr = 5;
		jNode0.keepInGpu = (int *) malloc(sizeof(int) * 5);
		CHECK_POINTER(jNode0.keepInGpu);
		for(int k=0;k<5;k++)
			jNode0.keepInGpu[k] = 1;
		jNode0.rightOutputAttrNum = 0;
		jNode0.leftOutputAttrNum = 5;
		jNode0.leftOutputAttrType = (int *)malloc(sizeof(int)*5);
		CHECK_POINTER(jNode0.leftOutputAttrType);
		jNode0.leftOutputIndex = (int *)malloc(sizeof(int)*5);
		CHECK_POINTER(jNode0.leftOutputIndex);
		jNode0.leftPos = (int *)malloc(sizeof(int)*5);
		CHECK_POINTER(jNode0.leftPos);
		jNode0.tupleSize = 0;
		jNode0.leftOutputIndex[0] = 0;
		jNode0.leftOutputAttrType[0] = INT;
		jNode0.leftPos[0] = 0;
		jNode0.tupleSize += lineorderRes->attrSize[0];
		jNode0.leftOutputIndex[1] = 1;
		jNode0.leftOutputAttrType[1] = INT;
		jNode0.leftPos[1] = 1;
		jNode0.tupleSize += lineorderRes->attrSize[1];
		jNode0.leftOutputIndex[2] = 2;
		jNode0.leftOutputAttrType[2] = INT;
		jNode0.leftPos[2] = 2;
		jNode0.tupleSize += lineorderRes->attrSize[2];
		jNode0.leftOutputIndex[3] = 3;
		jNode0.leftOutputAttrType[3] = INT;
		jNode0.leftPos[3] = 3;
		jNode0.tupleSize += lineorderRes->attrSize[3];
		jNode0.leftOutputIndex[4] = 4;
		jNode0.leftOutputAttrType[4] = INT;
		jNode0.leftPos[4] = 4;
		jNode0.tupleSize += lineorderRes->attrSize[4];
		jNode0.rightOutputAttrType = (int *)malloc(sizeof(int)*0);
		CHECK_POINTER(jNode0.rightOutputAttrType);
		jNode0.rightOutputIndex = (int *)malloc(sizeof(int)*0);
		CHECK_POINTER(jNode0.rightOutputIndex);
		jNode0.rightPos = (int *)malloc(sizeof(int)*0);
		CHECK_POINTER(jNode0.rightPos);
		jNode0.rightKeyIndex = 0;
		jNode0.leftKeyIndex = 5;
		struct tableNode *join0 = hashJoin(&jNode0,&pp);

		struct joinNode jNode1;
		jNode1.leftTable = join0;
		jNode1.rightTable = supplierRes;
		jNode1.totalAttr = 5;
		jNode1.keepInGpu = (int *) malloc(sizeof(int) * 5);
		CHECK_POINTER(jNode1.keepInGpu);
		for(int k=0;k<5;k++)
			jNode1.keepInGpu[k] = 1;
		jNode1.rightOutputAttrNum = 1;
		jNode1.leftOutputAttrNum = 4;
		jNode1.leftOutputAttrType = (int *)malloc(sizeof(int)*4);
		CHECK_POINTER(jNode1.leftOutputAttrType);
		jNode1.leftOutputIndex = (int *)malloc(sizeof(int)*4);
		CHECK_POINTER(jNode1.leftOutputIndex);
		jNode1.leftPos = (int *)malloc(sizeof(int)*4);
		CHECK_POINTER(jNode1.leftPos);
		jNode1.tupleSize = 0;
		jNode1.leftOutputIndex[0] = 0;
		jNode1.leftOutputAttrType[0] = INT;
		jNode1.leftPos[0] = 1;
		jNode1.tupleSize += join0->attrSize[0];
		jNode1.leftOutputIndex[1] = 1;
		jNode1.leftOutputAttrType[1] = INT;
		jNode1.leftPos[1] = 2;
		jNode1.tupleSize += join0->attrSize[1];
		jNode1.leftOutputIndex[2] = 2;
		jNode1.leftOutputAttrType[2] = INT;
		jNode1.leftPos[2] = 3;
		jNode1.tupleSize += join0->attrSize[2];
		jNode1.leftOutputIndex[3] = 3;
		jNode1.leftOutputAttrType[3] = INT;
		jNode1.leftPos[3] = 4;
		jNode1.tupleSize += join0->attrSize[3];
		jNode1.rightOutputAttrType = (int *)malloc(sizeof(int)*1);
		CHECK_POINTER(jNode1.rightOutputAttrType);
		jNode1.rightOutputIndex = (int *)malloc(sizeof(int)*1);
		CHECK_POINTER(jNode1.rightOutputIndex);
		jNode1.rightPos = (int *)malloc(sizeof(int)*1);
		CHECK_POINTER(jNode1.rightPos);
		jNode1.rightOutputIndex[0] = 0;
		jNode1.rightOutputAttrType[0] = STRING;
		jNode1.rightPos[0] = 0;
		jNode1.tupleSize += supplierRes->attrSize[0];
		jNode1.rightKeyIndex = 1;
		jNode1.leftKeyIndex = 4;
		struct tableNode *join1 = hashJoin(&jNode1,&pp);

		struct joinNode jNode2;
		jNode2.leftTable = join1;
		jNode2.rightTable = partRes;
		jNode2.totalAttr = 5;
		jNode2.keepInGpu = (int *) malloc(sizeof(int) * 5);
		CHECK_POINTER(jNode2.keepInGpu);
		for(int k=0;k<5;k++)
			jNode2.keepInGpu[k] = 1;
		jNode2.rightOutputAttrNum = 1;
		jNode2.leftOutputAttrNum = 4;
		jNode2.leftOutputAttrType = (int *)malloc(sizeof(int)*4);
		CHECK_POINTER(jNode2.leftOutputAttrType);
		jNode2.leftOutputIndex = (int *)malloc(sizeof(int)*4);
		CHECK_POINTER(jNode2.leftOutputIndex);
		jNode2.leftPos = (int *)malloc(sizeof(int)*4);
		CHECK_POINTER(jNode2.leftPos);
		jNode2.tupleSize = 0;
		jNode2.leftOutputIndex[0] = 0;
		jNode2.leftOutputAttrType[0] = STRING;
		jNode2.leftPos[0] = 0;
		jNode2.tupleSize += join1->attrSize[0];
		jNode2.leftOutputIndex[1] = 1;
		jNode2.leftOutputAttrType[1] = INT;
		jNode2.leftPos[1] = 2;
		jNode2.tupleSize += join1->attrSize[1];
		jNode2.leftOutputIndex[2] = 2;
		jNode2.leftOutputAttrType[2] = INT;
		jNode2.leftPos[2] = 3;
		jNode2.tupleSize += join1->attrSize[2];
		jNode2.leftOutputIndex[3] = 3;
		jNode2.leftOutputAttrType[3] = INT;
		jNode2.leftPos[3] = 4;
		jNode2.tupleSize += join1->attrSize[3];
		jNode2.rightOutputAttrType = (int *)malloc(sizeof(int)*1);
		CHECK_POINTER(jNode2.rightOutputAttrType);
		jNode2.rightOutputIndex = (int *)malloc(sizeof(int)*1);
		CHECK_POINTER(jNode2.rightOutputIndex);
		jNode2.rightPos = (int *)malloc(sizeof(int)*1);
		CHECK_POINTER(jNode2.rightPos);
		jNode2.rightOutputIndex[0] = 0;
		jNode2.rightOutputAttrType[0] = STRING;
		jNode2.rightPos[0] = 1;
		jNode2.tupleSize += partRes->attrSize[0];
		jNode2.rightKeyIndex = 1;
		jNode2.leftKeyIndex = 4;
		struct tableNode *join2 = hashJoin(&jNode2,&pp);

		struct joinNode jNode3;
		jNode3.leftTable = join2;
		jNode3.rightTable = ddateRes;
		jNode3.totalAttr = 5;
		jNode3.keepInGpu = (int *) malloc(sizeof(int) * 5);
		CHECK_POINTER(jNode3.keepInGpu);
		for(int k=0;k<5;k++)
			jNode3.keepInGpu[k] = 1;
		jNode3.rightOutputAttrNum = 1;
		jNode3.leftOutputAttrNum = 4;
		jNode3.leftOutputAttrType = (int *)malloc(sizeof(int)*4);
		CHECK_POINTER(jNode3.leftOutputAttrType);
		jNode3.leftOutputIndex = (int *)malloc(sizeof(int)*4);
		CHECK_POINTER(jNode3.leftOutputIndex);
		jNode3.leftPos = (int *)malloc(sizeof(int)*4);
		CHECK_POINTER(jNode3.leftPos);
		jNode3.tupleSize = 0;
		jNode3.leftOutputIndex[0] = 0;
		jNode3.leftOutputAttrType[0] = STRING;
		jNode3.leftPos[0] = 1;
		jNode3.tupleSize += join2->attrSize[0];
		jNode3.leftOutputIndex[1] = 1;
		jNode3.leftOutputAttrType[1] = STRING;
		jNode3.leftPos[1] = 2;
		jNode3.tupleSize += join2->attrSize[1];
		jNode3.leftOutputIndex[2] = 2;
		jNode3.leftOutputAttrType[2] = INT;
		jNode3.leftPos[2] = 3;
		jNode3.tupleSize += join2->attrSize[2];
		jNode3.leftOutputIndex[3] = 3;
		jNode3.leftOutputAttrType[3] = INT;
		jNode3.leftPos[3] = 4;
		jNode3.tupleSize += join2->attrSize[3];
		jNode3.rightOutputAttrType = (int *)malloc(sizeof(int)*1);
		CHECK_POINTER(jNode3.rightOutputAttrType);
		jNode3.rightOutputIndex = (int *)malloc(sizeof(int)*1);
		CHECK_POINTER(jNode3.rightOutputIndex);
		jNode3.rightPos = (int *)malloc(sizeof(int)*1);
		CHECK_POINTER(jNode3.rightPos);
		jNode3.rightOutputIndex[0] = 0;
		jNode3.rightOutputAttrType[0] = INT;
		jNode3.rightPos[0] = 0;
		jNode3.tupleSize += ddateRes->attrSize[0];
		jNode3.rightKeyIndex = 1;
		jNode3.leftKeyIndex = 4;
		struct tableNode *join3 = hashJoin(&jNode3,&pp);

		if(blockTotal !=1){
			mergeIntoTable(result,join3, &pp);
			clock_gettime(CLOCK_REALTIME,&diskStart);
			freeTable(join0);
			freeTable(join1);
			freeTable(join2);
			freeTable(join3);
			clock_gettime(CLOCK_REALTIME,&diskEnd);
			diskTotal += (diskEnd.tv_sec -  diskStart.tv_sec)* BILLION + diskEnd.tv_nsec - diskStart.tv_nsec;
		}else{
			clock_gettime(CLOCK_REALTIME,&diskStart);
			freeTable(result);
			result = join3;
			freeTable(join0);
			freeTable(join1);
			freeTable(join2);
			clock_gettime(CLOCK_REALTIME,&diskEnd);
			diskTotal += (diskEnd.tv_sec -  diskStart.tv_sec)* BILLION + diskEnd.tv_nsec - diskStart.tv_nsec;
		}
	}

	struct groupByNode * gbNode = (struct groupByNode *) malloc(sizeof(struct groupByNode));
	CHECK_POINTER(gbNode);
	gbNode->table = result;
	gbNode->groupByColNum = 3;
	gbNode->groupByIndex = (int *)malloc(sizeof(int) * 3);
	CHECK_POINTER(gbNode->groupByIndex);
	gbNode->groupByType = (int *)malloc(sizeof(int) * 3);
	CHECK_POINTER(gbNode->groupByType);
	gbNode->groupBySize = (int *)malloc(sizeof(int) * 3);
	CHECK_POINTER(gbNode->groupBySize);
	gbNode->groupByIndex[0] = 0;
	gbNode->groupByType[0] = gbNode->table->attrType[0];
	gbNode->groupBySize[0] = gbNode->table->attrSize[0];
	gbNode->groupByIndex[1] = 1;
	gbNode->groupByType[1] = gbNode->table->attrType[1];
	gbNode->groupBySize[1] = gbNode->table->attrSize[1];
	gbNode->groupByIndex[2] = 2;
	gbNode->groupByType[2] = gbNode->table->attrType[2];
	gbNode->groupBySize[2] = gbNode->table->attrSize[2];
	gbNode->outputAttrNum = 4;
	gbNode->attrType = (int *) malloc(sizeof(int) *4);
	CHECK_POINTER(gbNode->attrType);
	gbNode->attrSize = (int *) malloc(sizeof(int) *4);
	CHECK_POINTER(gbNode->attrSize);
	gbNode->tupleSize = 0;
	gbNode->gbExp = (struct groupByExp *) malloc(sizeof(struct groupByExp) * 4);
	CHECK_POINTER(gbNode->gbExp);
	gbNode->attrType[0] = result->attrType[0];
	gbNode->attrSize[0] = result->attrSize[0];
	gbNode->tupleSize += result->attrSize[0];
	gbNode->gbExp[0].func = NOOP;
	gbNode->gbExp[0].exp.op = NOOP;
	gbNode->gbExp[0].exp.exp = NULL;
	gbNode->gbExp[0].exp.opNum = 1;
	gbNode->gbExp[0].exp.opType = COLUMN;
	gbNode->gbExp[0].exp.opValue = 0;
	gbNode->attrType[1] = result->attrType[1];
	gbNode->attrSize[1] = result->attrSize[1];
	gbNode->tupleSize += result->attrSize[1];
	gbNode->gbExp[1].func = NOOP;
	gbNode->gbExp[1].exp.op = NOOP;
	gbNode->gbExp[1].exp.exp = NULL;
	gbNode->gbExp[1].exp.opNum = 1;
	gbNode->gbExp[1].exp.opType = COLUMN;
	gbNode->gbExp[1].exp.opValue = 1;
	gbNode->attrType[2] = result->attrType[2];
	gbNode->attrSize[2] = result->attrSize[2];
	gbNode->tupleSize += result->attrSize[2];
	gbNode->gbExp[2].func = NOOP;
	gbNode->gbExp[2].exp.op = NOOP;
	gbNode->gbExp[2].exp.exp = NULL;
	gbNode->gbExp[2].exp.opNum = 1;
	gbNode->gbExp[2].exp.opType = COLUMN;
	gbNode->gbExp[2].exp.opValue = 2;
	gbNode->tupleSize += sizeof(float);
	gbNode->attrType[3] = FLOAT;
	gbNode->attrSize[3] = sizeof(float);
	gbNode->gbExp[3].func = SUM;
	gbNode->gbExp[3].exp.op = MINUS;
	gbNode->gbExp[3].exp.opNum = 2;
	gbNode->gbExp[3].exp.exp = (long) malloc(sizeof(struct mathExp) * 2);
((struct mathExp *)	gbNode->gbExp[3].exp.exp)[0].op = NOOP;
((struct mathExp *)	gbNode->gbExp[3].exp.exp)[0].opNum = 1;
((struct mathExp *)	gbNode->gbExp[3].exp.exp)[0].exp = 0;
((struct mathExp *)	gbNode->gbExp[3].exp.exp)[0].opType = COLUMN;
((struct mathExp *)	gbNode->gbExp[3].exp.exp)[0].opValue = 3;
((struct mathExp *)	gbNode->gbExp[3].exp.exp)[1].op = NOOP;
((struct mathExp *)	gbNode->gbExp[3].exp.exp)[1].opNum = 1;
((struct mathExp *)	gbNode->gbExp[3].exp.exp)[1].exp = 0;
((struct mathExp *)	gbNode->gbExp[3].exp.exp)[1].opType = COLUMN;
((struct mathExp *)	gbNode->gbExp[3].exp.exp)[1].opValue = 4;
	struct tableNode * gbResult = groupBy(gbNode, &pp);
	freeGroupByNode(gbNode);

	struct orderByNode * odNode = (struct orderByNode *) malloc(sizeof(struct orderByNode));
	CHECK_POINTER(odNode);
	odNode->table = gbResult;
	odNode->orderByNum = 3;
	odNode->orderBySeq = (int *) malloc(sizeof(int) * odNode->orderByNum);
	CHECK_POINTER(odNode->orderBySeq);
	odNode->orderByIndex = (int *) malloc(sizeof(int) * odNode->orderByNum);
	CHECK_POINTER(odNode->orderByIndex);
	odNode->orderBySeq[0] = ASC;
	odNode->orderByIndex[0] = 0;
	odNode->orderBySeq[1] = ASC;
	odNode->orderByIndex[1] = 1;
	odNode->orderBySeq[2] = ASC;
	odNode->orderByIndex[2] = 2;
	struct tableNode * odResult = orderBy(odNode,&pp);
	freeOrderByNode(odNode);

	struct materializeNode mn;
	mn.table = odResult;
	materializeCol(&mn, &pp);
	freeTable(odResult);

	clock_gettime(CLOCK_REALTIME,&end);
	double timeE = (end.tv_sec -  start.tv_sec)* BILLION + end.tv_nsec - start.tv_nsec;
	printf("Disk Load Time: %lf\n", diskTotal/(1000*1000));
	printf("PCIe Time: %lf\n",pp.pcie);
	printf("Kernel Time: %lf\n",pp.kernel);
	printf("Total Time: %lf\n", timeE/(1000*1000));
}

int main(int argc, char ** argv){
	int i, times = atoi(argv[1]);
	for (i = 0; i < times; i ++) {
		printf("------------------------");
		call(argc, argv);
	}
}
