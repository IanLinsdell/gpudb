!_TAG_FILE_FORMAT	2	/extended format; --format=1 will not append ;" to lines/
!_TAG_FILE_SORTED	1	/0=unsorted, 1=sorted, 2=foldcase/
!_TAG_PROGRAM_AUTHOR	Darren Hiebert	/dhiebert@users.sourceforge.net/
!_TAG_PROGRAM_NAME	Exuberant Ctags	//
!_TAG_PROGRAM_URL	http://ctags.sourceforge.net	/official site/
!_TAG_PROGRAM_VERSION	5.8	//
.DEFAULT_GOAL	Makefile	/^.DEFAULT_GOAL := all$/;"	m
BLOCKIDX	core.h	98;"	d
BLOCKSIZE	core.h	30;"	d
BLOCKUP	core.h	99;"	d
CC	Makefile	/^CC := gcc$/;"	m
CFLAGS	Makefile	/^CFLAGS := -O -Wall -pthread -fPIC -fvisibility=hidden \\$/;"	m
CUDAPATH	Makefile	/^CUDAPATH = \/home\/kai\/cuda-5.5$/;"	m
CUDA_CURT_PATH	interfaces.h	14;"	d
CUDA_CURT_PATH	interfaces.h	17;"	d
CUDA_CU_PATH	interfaces.h	13;"	d
CUDA_CU_PATH	interfaces.h	16;"	d
ENABLE_DEBUG	gmm.mk	/^ENABLE_DEBUG = 1$/;"	m
ENABLE_PROFILE	gmm.mk	/^ENABLE_PROFILE = 1$/;"	m
FLAG_DEBUG	Makefile	/^FLAG_DEBUG = -DGMM_DEBUG$/;"	m
FLAG_DEBUG	Makefile	/^FLAG_DEBUG =$/;"	m
FLAG_PROFILE	Makefile	/^FLAG_PROFILE = -DGMM_PROFILE$/;"	m
FLAG_PROFILE	Makefile	/^FLAG_PROFILE =$/;"	m
GMM_CONFIGS	gmm.mk	/^GMM_CONFIGS :=$/;"	m
GMM_DPRINT	common.h	10;"	d
GMM_DPRINT	common.h	12;"	d
GMM_EXPORT	common.h	7;"	d
GMM_PRINT	common.h	16;"	d
GMM_PRINT	common.h	18;"	d
GMM_SEM_LAUNCH	protocol.h	74;"	d
GMM_SHM_GLOBAL	protocol.h	75;"	d
HINT_DEFAULT	hint.h	7;"	d
HINT_READ	hint.h	5;"	d
HINT_WRITE	hint.h	6;"	d
ILIST_ADD	protocol.h	/^static inline void ILIST_ADD(struct gmm_global *p, int inew)$/;"	f
ILIST_DEL	protocol.h	/^static inline void ILIST_DEL(struct gmm_global *p, int idel)$/;"	f
ILIST_MOV	protocol.h	/^static inline void ILIST_MOV(struct gmm_global *p, int imov)$/;"	f
INIT_LIST_HEAD	list.h	/^static inline void INIT_LIST_HEAD(struct list_head *list)$/;"	f
INTERCEPT_CUDA	interfaces.h	31;"	d
INTERCEPT_CUDA2	interfaces.h	39;"	d
LDFLAGS	Makefile	/^LDFLAGS := -shared -pthread -ldl -fPIC$/;"	m
LD_PRELOAD	Makefile	/^	LD_PRELOAD=`pwd`\/$(LIBGMM) .\/test$/;"	m
LIBGMM	Makefile	/^LIBGMM = libgmm.so$/;"	m
MIN	core.h	95;"	d
MSG_REP_ACK	protocol.h	/^	MSG_REP_ACK,$/;"	e	enum:msgtype
MSG_REQ_EVICT	protocol.h	/^	MSG_REQ_EVICT,$/;"	e	enum:msgtype
NCLIENTS	protocol.h	12;"	d
NRBLOCKS	core.h	97;"	d
NREFS	core.h	59;"	d
NVCC	Makefile	/^NVCC := $(CUDAPATH)\/bin\/nvcc$/;"	m
OBJS	Makefile	/^OBJS = client.o common.o core.o interfaces.o msq.o replacement.o$/;"	m
OFFSETOF	list.h	85;"	d
PRIO_DEFAULT	hint.h	11;"	d
PRIO_LOWEST	hint.h	10;"	d
QLEN	queue.h	7;"	d
SRCS	Makefile	/^SRCS = client.c common.c core.c interfaces.c msq.c replacement.c$/;"	m
STATE_ATTACHED	core.h	/^	STATE_ATTACHED = 0,		\/\/ object allocated with device memory$/;"	e	enum:region_state
STATE_DETACHED	core.h	/^	STATE_DETACHED,			\/\/ object not attached with device memory$/;"	e	enum:region_state
STATE_EVICTED	core.h	/^	STATE_EVICTED$/;"	e	enum:region_state
STATE_EVICTING	core.h	/^	STATE_EVICTING,			\/\/ object being evicted$/;"	e	enum:region_state
STATE_FREEING	core.h	/^	STATE_FREEING,			\/\/ object being freed$/;"	e	enum:region_state
TREAT_ERROR	interfaces.h	21;"	d
TRY_ACQUIRE_TIMES	spinlock.h	42;"	d
_GMM_ATOMIC_H_	atomic.h	2;"	d
_GMM_CLIENT_H_	client.h	2;"	d
_GMM_COMMON_H_	common.h	2;"	d
_GMM_CORE_H_	core.h	2;"	d
_GMM_HINT_H_	hint.h	2;"	d
_GMM_H_	gmm.h	3;"	d
_GMM_INTERFACES_H_	interfaces.h	2;"	d
_GMM_LIST_H_	list.h	2;"	d
_GMM_MSQ_H_	msq.h	2;"	d
_GMM_PROTOCOL_H_	protocol.h	4;"	d
_GMM_QUEUE_H_	queue.h	3;"	d
_GMM_REPLACEMENT_H_	replacement.h	2;"	d
_GMM_SPINLOCK_H_	spinlock.h	3;"	d
_GNU_SOURCE	common.h	22;"	d
_GNU_SOURCE	interfaces.h	4;"	d
__list_add	list.h	/^static inline void __list_add($/;"	f
__list_del	list.h	/^static inline void __list_del(struct list_head * prev, struct list_head * next)$/;"	f
ack	msq.c	/^int ack = 0;$/;"	v
acquire	spinlock.h	/^static inline void acquire(struct spinlock *lk)$/;"	f
argoff	core.h	/^	unsigned long argoff;	\/\/ this argument's offset in the argument stack$/;"	m	struct:dptr_arg
atomic_add	atomic.h	/^static inline int atomic_add(atomic_t *ptr, int val)$/;"	f
atomic_dec	atomic.h	/^static inline int atomic_dec(atomic_t *ptr)$/;"	f
atomic_inc	atomic.h	/^static inline int atomic_inc(atomic_t *ptr)$/;"	f
atomic_read	atomic.h	/^static inline int atomic_read(atomic_t *ptr)$/;"	f
atomic_set	atomic.h	/^static inline void atomic_set(atomic_t *ptr, int val)$/;"	f
atomic_sub	atomic.h	/^static inline int atomic_sub(atomic_t *ptr, int val)$/;"	f
atomic_t	atomic.h	/^typedef int atomic_t;$/;"	t
block	core.h	/^struct block {$/;"	s
block	protocol.h	/^	int block;$/;"	m	struct:msg_req
block_sync	core.c	/^static void block_sync(struct region *r, int block)$/;"	f	file:
blocks	core.h	/^	struct block *blocks;	\/\/ device memory blocks$/;"	m	struct:region	typeref:struct:region::block
cid	client.c	/^int cid = -1;						\/\/ Id of this client$/;"	v
cidtopid	client.c	/^pid_t cidtopid(int cid)$/;"	f
client	core.h	/^	int client;				\/\/ for a remote victim$/;"	m	struct:victim
client_alloc	client.c	/^static int client_alloc()$/;"	f	file:
client_attach	client.c	/^int client_attach()$/;"	f
client_detach	client.c	/^void client_detach() {$/;"	f
client_free	client.c	/^static void client_free(int id)$/;"	f	file:
client_lru_detachable	client.c	/^int client_lru_detachable()$/;"	f
client_unpin	client.c	/^void client_unpin(int client)$/;"	f
clients	protocol.h	/^	struct gmm_client clients[NCLIENTS];$/;"	m	struct:gmm_global	typeref:struct:gmm_global::gmm_client
cond_ack	msq.c	/^pthread_cond_t cond_ack;$/;"	v
cudaConfigureCall	interfaces.c	/^cudaError_t cudaConfigureCall($/;"	f
cudaFree	interfaces.c	/^cudaError_t cudaFree(void *devPtr)$/;"	f
cudaLaunch	interfaces.c	/^cudaError_t cudaLaunch(const void *entry)$/;"	f
cudaMalloc	interfaces.c	/^cudaError_t cudaMalloc(void **devPtr, size_t size)$/;"	f
cudaMemGetInfo	interfaces.c	/^cudaError_t cudaMemGetInfo(size_t *free, size_t *total)$/;"	f
cudaMemcpy	interfaces.c	/^cudaError_t cudaMemcpy($/;"	f
cudaMemset	interfaces.c	/^cudaError_t cudaMemset(void * devPtr, int value, size_t count)$/;"	f
cudaReference	interfaces.c	/^cudaError_t cudaReference(int which_arg, int flags)$/;"	f
cudaSetKernelPrio	interfaces.c	/^cudaError_t cudaSetKernelPrio(int prio)$/;"	f
cudaSetupArgument	interfaces.c	/^cudaError_t cudaSetupArgument($/;"	f
dargs	core.c	/^static struct dptr_arg dargs[NREFS];$/;"	v	typeref:struct:dptr_arg	file:
dev_addr	core.h	/^	void *dev_addr;			\/\/ device memory address$/;"	m	struct:region
dev_valid	core.h	/^	int dev_valid;			\/\/ if data copy on device is valid$/;"	m	struct:block
dptr	core.h	/^	void *dptr;				\/\/ the actual device memory address$/;"	m	struct:dptr_arg
dptr_arg	core.h	/^struct dptr_arg {$/;"	s
elems	queue.h	/^	void elems[QLEN];$/;"	m	struct:queue
entry	core.h	/^	struct list_head entry;$/;"	m	struct:victim	typeref:struct:victim::list_head
entry_alloced	core.h	/^	struct list_head entry_alloced;		\/\/ linked to the list of allocated$/;"	m	struct:region	typeref:struct:region::list_head
entry_attached	core.h	/^	struct list_head entry_attached;	\/\/ linked to the list of attached$/;"	m	struct:region	typeref:struct:region::list_head
flags	core.h	/^	int flags;$/;"	m	struct:dptr_arg
flags	core.h	/^	int flags;$/;"	m	struct:rwhint
from	protocol.h	/^	int from;$/;"	m	struct:msg_rep
from	protocol.h	/^	int from;$/;"	m	struct:msg_req
getcid	client.c	/^int getcid()$/;"	f
gettid	common.h	/^static inline pid_t gettid()$/;"	f
gmm_client	protocol.h	/^struct gmm_client {$/;"	s
gmm_context	core.h	/^struct gmm_context {$/;"	s
gmm_context_fini	core.c	/^void gmm_context_fini()$/;"	f
gmm_context_init	core.c	/^int gmm_context_init()$/;"	f
gmm_cudaConfigureCall	core.c	/^cudaError_t gmm_cudaConfigureCall($/;"	f
gmm_cudaFree	core.c	/^cudaError_t gmm_cudaFree(void *devPtr)$/;"	f
gmm_cudaLaunch	core.c	/^cudaError_t gmm_cudaLaunch(const char *entry)$/;"	f
gmm_cudaMalloc	core.c	/^cudaError_t gmm_cudaMalloc(void **devPtr, size_t size)$/;"	f
gmm_cudaMemGetInfo	core.c	/^cudaError_t gmm_cudaMemGetInfo(size_t *free, size_t *total)$/;"	f
gmm_cudaMemcpyDtoH	core.c	/^cudaError_t gmm_cudaMemcpyDtoH($/;"	f
gmm_cudaMemcpyHtoD	core.c	/^cudaError_t gmm_cudaMemcpyHtoD($/;"	f
gmm_cudaMemset	core.c	/^cudaError_t gmm_cudaMemset(void * devPtr, int value, size_t count)$/;"	f
gmm_cudaSetupArgument	core.c	/^cudaError_t gmm_cudaSetupArgument($/;"	f
gmm_dtoh	core.c	/^static int gmm_dtoh($/;"	f	file:
gmm_dtoh_block	core.c	/^static int gmm_dtoh_block($/;"	f	file:
gmm_evict	core.c	/^static int gmm_evict(long size_needed, struct region **excls, int nexcl)$/;"	f	file:
gmm_fini	interfaces.c	/^void gmm_fini(void)$/;"	f
gmm_free	core.c	/^static int gmm_free(struct region *r)$/;"	f	file:
gmm_global	protocol.h	/^struct gmm_global {$/;"	s
gmm_htod	core.c	/^static int gmm_htod($/;"	f	file:
gmm_htod_block	core.c	/^static void gmm_htod_block($/;"	f	file:
gmm_init	interfaces.c	/^void gmm_init(void)$/;"	f
gmm_kernel_callback	core.c	/^void CUDART_CB gmm_kernel_callback($/;"	f
gmm_launch	core.c	/^static int gmm_launch(const char *entry, struct region **rgns, int nrgns)$/;"	f	file:
gmm_load	core.c	/^static int gmm_load(struct region **rgns, int n)$/;"	f	file:
gmm_memcpy_dtoh	core.c	/^static int gmm_memcpy_dtoh(void *dst, const void *src, unsigned long size)$/;"	f	file:
gmm_memcpy_htod	core.c	/^static int gmm_memcpy_htod(void *dst, const void *src, unsigned long size)$/;"	f	file:
handle_rep_ack	msq.c	/^void handle_rep_ack(struct msg_rep *msg)$/;"	f
handle_req_evict	msq.c	/^void handle_req_evict(struct msg_req *msg)$/;"	f
head	queue.h	/^	int head;$/;"	m	struct:queue
iarg	core.c	/^static int iarg = 0;$/;"	v	file:
ilru	protocol.h	/^	int ilru;$/;"	m	struct:gmm_global
imru	protocol.h	/^	int imru;$/;"	m	struct:gmm_global
index	protocol.h	/^	int index;				\/\/ index of this client; -1 means unoccupied$/;"	m	struct:gmm_client
inext	protocol.h	/^	int inext;				\/\/ index of the next client in the LRU list$/;"	m	struct:gmm_client
initialized	interfaces.c	/^static int initialized = 0;$/;"	v	file:
initlock	spinlock.h	/^static inline void initlock(struct spinlock *lk)$/;"	f
iprev	protocol.h	/^	int iprev;				\/\/ index of the previous client in the LRU list$/;"	m	struct:gmm_client
is_client_local	client.c	/^int is_client_local(int client)$/;"	f
is_included	core.h	/^static inline int is_included(void **a, int n, void *p)$/;"	f
kcb	core.h	/^struct kcb {$/;"	s
latomic_add	atomic.h	/^static inline long latomic_add(latomic_t *ptr, long val)$/;"	f
latomic_dec	atomic.h	/^static inline long latomic_dec(latomic_t *ptr)$/;"	f
latomic_inc	atomic.h	/^static inline long latomic_inc(latomic_t *ptr)$/;"	f
latomic_read	atomic.h	/^static inline int latomic_read(latomic_t *ptr)$/;"	f
latomic_set	atomic.h	/^static inline void latomic_set(latomic_t *ptr, long val)$/;"	f
latomic_sub	atomic.h	/^static inline long latomic_sub(latomic_t *ptr, long val)$/;"	f
latomic_t	atomic.h	/^typedef long latomic_t;$/;"	t
launch_signal	client.c	/^void launch_signal()$/;"	f
launch_wait	client.c	/^void launch_wait()$/;"	f
list_add	list.h	/^static inline void list_add(struct list_head *add, struct list_head *head)$/;"	f
list_add_tail	list.h	/^static inline void list_add_tail(struct list_head *add, struct list_head *head)$/;"	f
list_alloced	core.h	/^	struct list_head list_alloced;		\/\/ List of all allocated mem regions$/;"	m	struct:gmm_context	typeref:struct:gmm_context::list_head
list_alloced_add	core.c	/^static void list_alloced_add(struct gmm_context *ctx, struct region *r)$/;"	f	file:
list_alloced_del	core.c	/^static void list_alloced_del(struct gmm_context *ctx, struct region *r)$/;"	f	file:
list_attached	core.h	/^	struct list_head list_attached;		\/\/ LRU list of attached mem regions$/;"	m	struct:gmm_context	typeref:struct:gmm_context::list_head
list_attached_add	core.c	/^static void list_attached_add(struct gmm_context *ctx, struct region *r)$/;"	f	file:
list_attached_del	core.c	/^static void list_attached_del(struct gmm_context *ctx, struct region *r)$/;"	f	file:
list_attached_mov	core.c	/^static void list_attached_mov(struct gmm_context *ctx, struct region *r)$/;"	f	file:
list_del	list.h	/^static inline void list_del(struct list_head *entry)$/;"	f
list_empty	list.h	/^static inline int list_empty(const struct list_head *head)$/;"	f
list_entry	list.h	88;"	d
list_for_each	list.h	72;"	d
list_for_each_prev	list.h	76;"	d
list_head	list.h	/^struct list_head {$/;"	s
list_move	list.h	/^static inline void list_move(struct list_head *list, struct list_head *head)$/;"	f
list_move_tail	list.h	/^static inline void list_move_tail($/;"	f
local_victim_evict	core.c	/^int local_victim_evict(long size_needed)$/;"	f
lock	core.h	/^	struct spinlock lock;				\/\/ TODO: what's the use of this lock??$/;"	m	struct:gmm_context	typeref:struct:gmm_context::spinlock
lock	core.h	/^	struct spinlock lock;	\/\/ r\/w lock$/;"	m	struct:block	typeref:struct:block::spinlock
lock	core.h	/^	struct spinlock lock;	\/\/ the lock that protects memory object state$/;"	m	struct:region	typeref:struct:region::spinlock
lock	protocol.h	/^	struct spinlock lock;		\/\/ This lock works only when the hardware cache$/;"	m	struct:gmm_global	typeref:struct:gmm_global::spinlock
lock	queue.h	/^	struct spinlock lock;$/;"	m	struct:queue	typeref:struct:queue::spinlock
lock_alloced	core.h	/^	struct spinlock lock_alloced;$/;"	m	struct:gmm_context	typeref:struct:gmm_context::spinlock
lock_attached	core.h	/^	struct spinlock lock_attached;$/;"	m	struct:gmm_context	typeref:struct:gmm_context::spinlock
locked	spinlock.h	/^	unsigned int locked;$/;"	m	struct:spinlock
main	server.c	/^int main(int argc, char *argv[])$/;"	f
mem_total	protocol.h	/^	long mem_total;				\/\/ Total size of device memory.$/;"	m	struct:gmm_global
mem_used	protocol.h	/^	latomic_t mem_used;			\/\/ Size of used (attached) device memory$/;"	m	struct:gmm_global
memsize_free	client.c	/^long memsize_free()$/;"	f
memsize_free2	client.c	/^long memsize_free2()$/;"	f
memsize_total	client.c	/^long memsize_total()$/;"	f
mqid	msq.c	/^mqd_t mqid = (mqd_t) -1;$/;"	v
msg	protocol.h	/^struct msg {$/;"	s
msg_rep	protocol.h	/^struct msg_rep {$/;"	s
msg_req	protocol.h	/^struct msg_req {$/;"	s
msgtype	protocol.h	/^enum msgtype {$/;"	g
msq_fini	msq.c	/^void msq_fini()$/;"	f
msq_init	msq.c	/^int msq_init()$/;"	f
msq_send	msq.c	/^int msq_send(int client, const struct msg *msg)$/;"	f
msq_send_rep_ack	msq.c	/^int msq_send_rep_ack(int client, int ack)$/;"	f
msq_send_req_evict	msq.c	/^int msq_send_req_evict(int client, long size_needed, int block)$/;"	f
mutx_ack	msq.c	/^pthread_mutex_t mutx_ack;$/;"	v
nargs	core.c	/^static int nargs = 0;$/;"	v	file:
nclients	protocol.h	/^	int nclients;$/;"	m	struct:gmm_global
next	list.h	/^	struct list_head *next;$/;"	m	struct:list_head	typeref:struct:list_head::list_head
nrefs	interfaces.c	/^int nrefs = 0;$/;"	v
nrgns	core.h	/^	int nrgns;					\/\/ Number of regions referenced$/;"	m	struct:kcb
nv_cudaConfigureCall	interfaces.c	/^cudaError_t (*nv_cudaConfigureCall)(dim3, dim3, size_t, cudaStream_t) = NULL;$/;"	v
nv_cudaFree	interfaces.c	/^cudaError_t (*nv_cudaFree)(void *) = NULL;$/;"	v
nv_cudaLaunch	interfaces.c	/^cudaError_t (*nv_cudaLaunch)(const void *) = NULL;$/;"	v
nv_cudaMalloc	interfaces.c	/^cudaError_t (*nv_cudaMalloc)(void **, size_t) = NULL;$/;"	v
nv_cudaMemGetInfo	interfaces.c	/^cudaError_t (*nv_cudaMemGetInfo)(size_t*, size_t*) = NULL;$/;"	v
nv_cudaMemcpy	interfaces.c	/^cudaError_t (*nv_cudaMemcpy)(void *, const void *,$/;"	v
nv_cudaMemcpyAsync	interfaces.c	/^cudaError_t (*nv_cudaMemcpyAsync)(void *, const void *,$/;"	v
nv_cudaMemset	interfaces.c	/^cudaError_t (*nv_cudaMemset)(void * , int , size_t ) = NULL;$/;"	v
nv_cudaSetupArgument	interfaces.c	/^cudaError_t (*nv_cudaSetupArgument) (const void *, size_t, size_t) = NULL;$/;"	v
nv_cudaStreamAddCallback	interfaces.c	/^cudaError_t (*nv_cudaStreamAddCallback)(cudaStream_t,$/;"	v
nv_cudaStreamCreate	interfaces.c	/^cudaError_t (*nv_cudaStreamCreate)(cudaStream_t *) = NULL;$/;"	v
nv_cudaStreamDestroy	interfaces.c	/^cudaError_t (*nv_cudaStreamDestroy)(cudaStream_t) = NULL;$/;"	v
nv_cudaStreamSynchronize	interfaces.c	/^cudaError_t (*nv_cudaStreamSynchronize)(cudaStream_t) = NULL;$/;"	v
off	core.h	/^	unsigned long off;		\/\/ device pointer offset in the region$/;"	m	struct:dptr_arg
panic	common.c	/^void panic(char *msg)$/;"	f
pcontext	core.c	/^struct gmm_context *pcontext = NULL;$/;"	v	typeref:struct:gmm_context
pglobal	client.c	/^struct gmm_global *pglobal = NULL;	\/\/ Global shared memory$/;"	v	typeref:struct:gmm_global
pid	protocol.h	/^	pid_t pid;$/;"	m	struct:gmm_client
pinned	core.h	/^	atomic_t pinned;		\/\/ atomic pin counter$/;"	m	struct:region
pinned	protocol.h	/^	int pinned;$/;"	m	struct:gmm_client
prev	list.h	/^	struct list_head *prev;$/;"	m	struct:list_head	typeref:struct:list_head::list_head
prio_kernel	interfaces.c	/^int prio_kernel = PRIO_DEFAULT;$/;"	v
qget	queue.h	/^static inline void *qget(struct queue *q)$/;"	f
qinit	queue.h	/^static inline void qinit(struct queue *q)$/;"	f
qlock	queue.h	/^static inline void qlock(struct queue *q)$/;"	f
qpop	queue.h	/^static inline void *qpop(struct queue *q)$/;"	f
qpush	queue.h	/^static inline int qpush(struct queue *q, void *elem)$/;"	f
queue	queue.h	/^struct queue {$/;"	s
qunlock	queue.h	/^static inline void qunlock(struct queue *q)$/;"	f
r	core.h	/^	struct region *r;		\/\/ for a local victim$/;"	m	struct:victim	typeref:struct:victim::region
r	core.h	/^	struct region *r;		\/\/ the region this argument points to$/;"	m	struct:dptr_arg	typeref:struct:dptr_arg::region
refs	interfaces.c	/^int refs[NREFS];$/;"	v
region	core.h	/^struct region {$/;"	s
region_attach	core.c	/^static int region_attach($/;"	f	file:
region_evict	core.c	/^int region_evict(struct region *r)$/;"	f
region_inval	core.h	/^static inline void region_inval(struct region *r, int swp)$/;"	f
region_load	core.c	/^static int region_load($/;"	f	file:
region_lookup	core.c	/^static struct region *region_lookup(struct gmm_context *ctx, const void *ptr)$/;"	f	file:
region_pin	core.c	/^static inline void region_pin(struct region *r)$/;"	f	file:
region_pinned	core.h	103;"	d
region_state	core.h	/^typedef enum region_state {$/;"	g
region_state_t	core.h	/^} region_state_t;$/;"	t	typeref:enum:region_state
region_unpin	core.c	/^static inline void region_unpin(struct region *r)$/;"	f	file:
region_valid	core.h	/^static inline void region_valid(struct region *r, int swp)$/;"	f
regions_referenced	core.c	/^static long regions_referenced(struct region ***prgns, int *pnrgns)$/;"	f	file:
release	spinlock.h	/^static inline void release(struct spinlock *lk)$/;"	f
remote_victim_evict	core.c	/^int remote_victim_evict(int client, long size_needed)$/;"	f
restart	server.c	/^int restart()$/;"	f
ret	protocol.h	/^	int ret;$/;"	m	struct:msg_rep
rgns	core.h	/^	struct region *rgns[NREFS];	\/\/ Regions referenced by the kernel$/;"	m	struct:kcb	typeref:struct:kcb::region
rwflags	interfaces.c	/^int rwflags[NREFS];$/;"	v
rwhint	core.h	/^	struct rwhint rwhint;	\/\/ rw hint$/;"	m	struct:region	typeref:struct:region::rwhint
rwhint	core.h	/^struct rwhint {$/;"	s
sem_launch	client.c	/^sem_t *sem_launch = SEM_FAILED;		\/\/ Guarding kernel launches$/;"	v
show_stackframe	common.c	/^static void show_stackframe() {$/;"	f	file:
size	core.h	/^	long size;				\/\/ size of the object in bytes$/;"	m	struct:region
size	protocol.h	/^	int size;$/;"	m	struct:msg
size	protocol.h	/^	int size;$/;"	m	struct:msg_rep
size	protocol.h	/^	int size;$/;"	m	struct:msg_req
size_attached	core.h	/^	latomic_t size_attached;			\/\/ Total size of attached mem regions$/;"	m	struct:gmm_context
size_detachable	protocol.h	/^	long size_detachable;	\/\/ TODO: update it correctly$/;"	m	struct:gmm_client
size_needed	protocol.h	/^	long size_needed;$/;"	m	struct:msg_req
spinlock	spinlock.h	/^struct spinlock {$/;"	s
start	server.c	/^int start()$/;"	f
state	core.h	/^	region_state_t state;	\/\/ state of the object$/;"	m	struct:region
stop	server.c	/^int stop()$/;"	f
stream_dma	core.h	/^	cudaStream_t stream_dma;			\/\/ The CUDA stream for DMA operations$/;"	m	struct:gmm_context
stream_issue	core.c	/^static cudaStream_t stream_issue = 0;$/;"	v	file:
stream_kernel	core.h	/^	cudaStream_t stream_kernel;			\/\/ The CUDA stream for kernel launches$/;"	m	struct:gmm_context
swp_addr	core.h	/^	void *swp_addr;			\/\/ host swap buffer address$/;"	m	struct:region
swp_valid	core.h	/^	int swp_valid;			\/\/ if data copy in host swap buffer is valid$/;"	m	struct:block
tail	queue.h	/^	int tail;$/;"	m	struct:queue
thread_msq_listener	msq.c	/^void *thread_msq_listener(void *arg)$/;"	f
tid_msq	msq.c	/^pthread_t tid_msq;$/;"	v
try_acquire	spinlock.h	/^static inline int try_acquire(struct spinlock *lk)$/;"	f
type	protocol.h	/^	int type;$/;"	m	struct:msg
type	protocol.h	/^	int type;$/;"	m	struct:msg_rep
type	protocol.h	/^	int type;$/;"	m	struct:msg_req
update_attached	client.c	/^void update_attached(long delta)$/;"	f
update_detachable	client.c	/^void update_detachable(long delta)$/;"	f
victim	core.h	/^struct victim {$/;"	s
victim_evict	core.c	/^int victim_evict(struct victim *victim, long size_needed)$/;"	f
victim_select	core.c	/^int victim_select($/;"	f
victim_select_lfu	replacement.c	/^int victim_select_lfu($/;"	f
victim_select_lru	replacement.c	/^int victim_select_lru($/;"	f
victim_select_lru_local	replacement.c	/^int victim_select_lru_local($/;"	f
xchg	spinlock.h	/^static inline unsigned int xchg($/;"	f
